import { BoundValue, ValueOrPromise } from './binding';
import { Context } from './context';
/**
 * A function to provide resolution of injected values
 */
export interface ResolverFunction {
    (ctx: Context, injection: Injection): ValueOrPromise<BoundValue>;
}
/**
 * Descriptor for an injection point
 */
export interface Injection {
    bindingKey: string;
    metadata?: {
        [attribute: string]: BoundValue;
    };
    resolve?: ResolverFunction;
}
/**
 * A decorator to annotate method arguments for automatic injection
 * by LoopBack IoC container.
 *
 * Usage - Typescript:
 *
 * ```ts
 * class InfoController {
 *   @inject('authentication.user') public userName: string;
 *
 *   constructor(@inject('application.name') public appName: string) {
 *   }
 *   // ...
 * }
 * ```
 *
 * Usage - JavaScript:
 *
 *  - TODO(bajtos)
 *
 * @param bindingKey What binding to use in order to resolve the value of the
 * decorated constructor parameter or property.
 * @param metadata Optional metadata to help the injection
 * @param resolve Optional function to resolve the injection
 *
 */
export declare function inject(bindingKey: string, metadata?: Object, resolve?: ResolverFunction): (target: any, propertyKey?: string | symbol | undefined, propertyDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
/**
 * Return an array of injection objects for parameters
 * @param target The target class for constructor or static methods,
 * or the prototype for instance methods
 * @param methodName Method name, undefined for constructor
 */
export declare function describeInjectedArguments(target: any, method?: string | symbol): Injection[];
/**
 * Return a map of injection objects for properties
 * @param target The target class for static properties or
 * prototype for instance properties.
 */
export declare function describeInjectedProperties(target: any): {
    [p: string]: Injection;
};
