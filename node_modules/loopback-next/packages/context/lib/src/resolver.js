"use strict";
// Copyright IBM Corp. 2013,2017. All Rights Reserved.
// Node module: loopback
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const is_promise_1 = require("./is-promise");
const inject_1 = require("./inject");
/**
 * Create an instance of a class which constructor has arguments
 * decorated with `@inject`.
 *
 * The function returns a class when all dependencies were
 * resolved synchronously, or a Promise otherwise.
 *
 * @param ctor The class constructor to call.
 * @param ctx The context containing values for `@inject` resolution
 */
function instantiateClass(ctor, ctx) {
    const argsOrPromise = resolveInjectedArguments(ctor, ctx);
    const propertiesOrPromise = resolveInjectedProperties(ctor, ctx);
    let inst;
    if (is_promise_1.isPromise(argsOrPromise)) {
        // Instantiate the class asynchronously
        inst = argsOrPromise.then(args => new ctor(...args));
    }
    else {
        // Instantiate the class synchronously
        inst = new ctor(...argsOrPromise);
    }
    if (is_promise_1.isPromise(propertiesOrPromise)) {
        return propertiesOrPromise.then(props => {
            if (is_promise_1.isPromise(inst)) {
                // Inject the properties asynchrounously
                return inst.then(obj => Object.assign(obj, props));
            }
            else {
                // Inject the properties synchrounously
                return Object.assign(inst, props);
            }
        });
    }
    else {
        if (is_promise_1.isPromise(inst)) {
            // Inject the properties asynchrounously
            return inst.then(obj => Object.assign(obj, propertiesOrPromise));
        }
        else {
            // Inject the properties synchrounously
            return Object.assign(inst, propertiesOrPromise);
        }
    }
}
exports.instantiateClass = instantiateClass;
/**
 * Resolve the value or promise for a given injection
 * @param ctx Context
 * @param injection Descriptor of the injection
 */
function resolve(ctx, injection) {
    if (injection.resolve) {
        // A custom resolve function is provided
        return injection.resolve(ctx, injection);
    }
    // Default to resolve the value from the context by binding key
    const binding = ctx.getBinding(injection.bindingKey);
    return binding.getValue(ctx);
}
/**
 * Given a function with arguments decorated with `@inject`,
 * return the list of arguments resolved using the values
 * bound in `ctx`.

 * The function returns an argument array when all dependencies were
 * resolved synchronously, or a Promise otherwise.
 *
 * @param fn The function for which the arguments should be resolved.
 * @param ctx The context containing values for `@inject` resolution
 */
function resolveInjectedArguments(fn, ctx) {
    // NOTE: the array may be sparse, i.e.
    //   Object.keys(injectedArgs).length !== injectedArgs.length
    // Example value:
    //   [ , 'key1', , 'key2']
    const injectedArgs = inject_1.describeInjectedArguments(fn);
    const args = new Array(fn.length);
    let asyncResolvers = undefined;
    for (let ix = 0; ix < fn.length; ix++) {
        const injection = injectedArgs[ix];
        if (!injection.bindingKey && !injection.resolve) {
            throw new Error(`Cannot resolve injected arguments for function ${fn.name}: ` +
                `The argument ${ix + 1} was not decorated for dependency injection.`);
        }
        const valueOrPromise = resolve(ctx, injection);
        if (is_promise_1.isPromise(valueOrPromise)) {
            if (!asyncResolvers)
                asyncResolvers = [];
            asyncResolvers.push(valueOrPromise.then((v) => (args[ix] = v)));
        }
        else {
            args[ix] = valueOrPromise;
        }
    }
    if (asyncResolvers) {
        return Promise.all(asyncResolvers).then(() => args);
    }
    else {
        return args;
    }
}
exports.resolveInjectedArguments = resolveInjectedArguments;
function resolveInjectedProperties(fn, ctx) {
    const injectedProperties = inject_1.describeInjectedProperties(fn.prototype);
    const properties = {};
    let asyncResolvers = undefined;
    const propertyResolver = (p) => (v) => (properties[p] = v);
    for (const p in injectedProperties) {
        const injection = injectedProperties[p];
        if (!injection.bindingKey && !injection.resolve) {
            throw new Error(`Cannot resolve injected property for class ${fn.name}: ` +
                `The property ${p} was not decorated for dependency injection.`);
        }
        const valueOrPromise = resolve(ctx, injection);
        if (is_promise_1.isPromise(valueOrPromise)) {
            if (!asyncResolvers)
                asyncResolvers = [];
            asyncResolvers.push(valueOrPromise.then(propertyResolver(p)));
        }
        else {
            properties[p] = valueOrPromise;
        }
    }
    if (asyncResolvers) {
        return Promise.all(asyncResolvers).then(() => properties);
    }
    else {
        return properties;
    }
}
exports.resolveInjectedProperties = resolveInjectedProperties;
//# sourceMappingURL=resolver.js.map