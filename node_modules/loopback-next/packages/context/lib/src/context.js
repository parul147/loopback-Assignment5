"use strict";
// Copyright IBM Corp. 2013,2017. All Rights Reserved.
// Node module: loopback
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const binding_1 = require("./binding");
const is_promise_1 = require("./is-promise");
class Context {
    constructor(_parent) {
        this._parent = _parent;
        this.registry = new Map();
    }
    bind(key) {
        binding_1.Binding.validateKey(key);
        key = binding_1.Binding.normalizeKey(key);
        const keyExists = this.registry.has(key);
        if (keyExists) {
            const existingBinding = this.registry.get(key);
            const bindingIsLocked = existingBinding && existingBinding.isLocked;
            if (bindingIsLocked)
                throw new Error(`Cannot rebind key "${key}" to a locked binding`);
        }
        const binding = new binding_1.Binding(key);
        this.registry.set(key, binding);
        return binding;
    }
    contains(key) {
        key = binding_1.Binding.normalizeKey(key);
        return this.registry.has(key);
    }
    find(pattern) {
        let bindings = [];
        if (pattern) {
            // TODO(@superkhau): swap with production grade glob to regex lib
            pattern = binding_1.Binding.normalizeKey(pattern);
            const glob = new RegExp('^' + pattern.split('*').join('.*') + '$');
            this.registry.forEach(binding => {
                const isMatch = glob.test(binding.key);
                if (isMatch)
                    bindings.push(binding);
            });
        }
        else {
            bindings = Array.from(this.registry.values());
        }
        const parentBindings = this._parent && this._parent.find(pattern);
        return this._mergeWithParent(bindings, parentBindings);
    }
    findByTag(pattern) {
        const bindings = [];
        // TODO(@superkhau): swap with production grade glob to regex lib
        const glob = new RegExp('^' + pattern.split('*').join('.*') + '$');
        this.registry.forEach(binding => {
            const isMatch = Array.from(binding.tags).some(tag => glob.test(tag));
            if (isMatch)
                bindings.push(binding);
        });
        const parentBindings = this._parent && this._parent.findByTag(pattern);
        return this._mergeWithParent(bindings, parentBindings);
    }
    _mergeWithParent(childList, parentList) {
        if (!parentList)
            return childList;
        const additions = parentList.filter(parentBinding => {
            // children bindings take precedence
            return !childList.some(childBinding => childBinding.key === parentBinding.key);
        });
        return childList.concat(additions);
    }
    get(key) {
        try {
            const path = binding_1.Binding.getKeyPath(key);
            const binding = this.getBinding(key);
            return Promise.resolve(binding.getValue(this)).then(val => getValue(val, path));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    getSync(key) {
        const path = binding_1.Binding.getKeyPath(key);
        const binding = this.getBinding(key);
        const valueOrPromise = binding.getValue(this);
        if (is_promise_1.isPromise(valueOrPromise)) {
            throw new Error(`Cannot get ${key} synchronously: the value is a promise`);
        }
        return getValue(valueOrPromise, path);
    }
    getBinding(key) {
        key = binding_1.Binding.normalizeKey(key);
        const binding = this.registry.get(key);
        if (binding) {
            return binding;
        }
        if (this._parent) {
            return this._parent.getBinding(key);
        }
        throw new Error(`The key ${key} was not bound to any value.`);
    }
}
exports.Context = Context;
/**
 * Get the value by `.` notation
 * @param obj The source value
 * @param path A path to the nested property, such as `x`, `x.y`, `x.length`,
 * or `x.0`
 */
function getValue(obj, path) {
    if (!path)
        return obj;
    const props = path.split('.');
    let val = undefined;
    for (const p of props) {
        val = obj[p];
        if (val == null)
            return val;
        obj = val;
    }
    return val;
}
//# sourceMappingURL=context.js.map