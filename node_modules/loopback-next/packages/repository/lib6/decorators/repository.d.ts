import { Class } from '../common-types';
import { Model } from '../model';
import { Repository } from '../repository';
import { DataSource } from '../datasource';
/**
 * Metadata for a repository
 */
export declare class RepositoryMetadata {
    /**
     * Name of the predefined repository
     */
    name?: string;
    /**
     * Name of the model
     */
    modelName?: string;
    /**
     * Class of the model
     */
    modelClass?: Class<Model>;
    /**
     * Name of the data source
     */
    dataSourceName?: string;
    /**
     * Instance of the data source
     */
    dataSource?: DataSource;
    /**
     * Constructor for RepositoryMetadata
     *
     * @param model Name or class of the model. If the value is a string and
     * `dataSource` is not present, it will treated as the name of a predefined
     * repository
     * @param dataSource Name or instance of the data source
     *
     * For example:
     *
     * - new RepositoryMetadata(repoName);
     * - new RepositoryMetadata(modelName, dataSourceName);
     * - new RepositoryMetadata(modelClass, dataSourceInstance);
     * - new RepositoryMetadata(modelName, dataSourceInstance);
     * - new RepositoryMetadata(modelClass, dataSourceName);
     */
    constructor(modelOrRepo: string | Class<Model>, dataSource?: string | DataSource);
}
/**
 * Decorator for model definitions
 * @param model Name of the repo or name/class of the model
 * @param dataSource Name or instance of the data source
 * @returns {(target:AnyType)}
 *
 * For example:
 *
 * - @repository('myCustomerRepo')
 * - @repository('Customer', 'mysqlDataSource')
 * - @repository(Customer, mysqlDataSource)
 * - @repository('Customer', mysqlDataSource)
 * - @repository(Customer, 'mysqlDataSource')
 */
export declare function repository<T extends Model>(model: string | Class<T>, dataSource?: string | DataSource): (target: Object, key?: string | symbol | undefined, descriptor?: number | TypedPropertyDescriptor<Repository<T>> | undefined) => void;
