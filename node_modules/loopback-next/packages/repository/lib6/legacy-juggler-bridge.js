"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/repository
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.jugglerModule = require('loopback-datasource-juggler');
const context_1 = require("@loopback/context");
__export(require("./loopback-datasource-juggler"));
/* tslint:disable-next-line:variable-name */
exports.DataSourceConstructor = exports.jugglerModule.DataSource;
/* tslint:disable-next-line:variable-name */
exports.ModelBaseConstructor = exports.jugglerModule.ModelBaseClass;
/**
 * This is a bridge to the legacy DAO class. The function mixes DAO methods
 * into a model class and attach it to a given data source
 * @param modelClass {} Model class
 * @param ds {DataSource} Data source
 * @returns {} The new model class with DAO (CRUD) operations
 */
function bindModel(modelClass, ds) {
    const boundModelClass = class extends modelClass {
    };
    boundModelClass.attachTo(ds);
    return boundModelClass;
}
exports.bindModel = bindModel;
function ensurePromise(p) {
    if (p && context_1.isPromise(p)) {
        return p;
    }
    else {
        return Promise.reject(new Error('The value should be a Promise: ' + p));
    }
}
class DefaultCrudRepository {
    constructor(modelClass, dataSource) {
        this.modelClass = bindModel(modelClass, dataSource);
    }
    create(entity, options) {
        return ensurePromise(this.modelClass.create(entity, options));
    }
    createAll(entities, options) {
        return ensurePromise(this.modelClass.create(entities, options));
    }
    save(entity, options) {
        const idName = this.modelClass.definition.idName();
        let id;
        if (typeof entity.getId === 'function') {
            id = entity.getId();
        }
        else {
            id = entity[idName];
        }
        if (id == null) {
            return this.create(entity, options);
        }
        else {
            return this.replaceById(id, entity, options).then(result => (result ? entity : null));
        }
    }
    find(filter, options) {
        return ensurePromise(this.modelClass.find(filter, options));
    }
    findById(id, filter, options) {
        return ensurePromise(this.modelClass.findById(id, filter, options));
    }
    update(entity, options) {
        return this.updateById(entity.getId(), entity, options);
    }
    delete(entity, options) {
        return this.deleteById(entity.getId(), options);
    }
    updateAll(data, where, options) {
        return ensurePromise(this.modelClass.updateAll(where, data, options)).then(result => result.count);
    }
    updateById(id, data, options) {
        const idProp = this.modelClass.definition.idName();
        const where = {};
        where[idProp] = id;
        return this.updateAll(data, where, options).then(count => count > 0);
    }
    replaceById(id, data, options) {
        return ensurePromise(this.modelClass.replaceById(id, data, options)).then(result => !!result);
    }
    deleteAll(where, options) {
        return ensurePromise(this.modelClass.deleteAll(where, options)).then(result => result.count);
    }
    deleteById(id, options) {
        return ensurePromise(this.modelClass.deleteById(id, options)).then(result => result.count > 0);
    }
    count(where, options) {
        return ensurePromise(this.modelClass.count(where, options));
    }
    exists(id, options) {
        return ensurePromise(this.modelClass.exists(id, options));
    }
}
exports.DefaultCrudRepository = DefaultCrudRepository;
//# sourceMappingURL=legacy-juggler-bridge.js.map