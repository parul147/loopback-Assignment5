"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/repository
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Property definition for a model
 */
class PropertyDefinition {
    constructor(name, type = String) {
        this.name = name;
        this.type = type;
    }
}
exports.PropertyDefinition = PropertyDefinition;
/**
 * Definition for a model
 */
class ModelDefinition {
    constructor(name, properties, settings) {
        this.name = name;
        this.properties = properties || {};
        this.settings = settings || new Map();
    }
    /**
     * Add a property
     * @param property Property definition or name (string)
     * @param type Property type
     */
    addProperty(property, type) {
        if (property instanceof PropertyDefinition) {
            this.properties[property.name] = property;
        }
        else {
            this.properties[property] = new PropertyDefinition(property, type);
        }
        return this;
    }
    /**
     * Add a setting
     * @param name Setting name
     * @param value Setting value
     */
    addSetting(name, value) {
        this.settings[name] = value;
        return this;
    }
    /**
     * Get an array of definitions for ID properties, which are specified in
     * the model settings or properties with `id` attribute. For example,
     * ```
     * {
     *   settings: {
     *     id: ['id']
     *   }
     *   properties: {
     *     id: {
     *       type: 'string',
     *       id: true
     *     }
     *   }
     * }
     * ```
     */
    idProperties() {
        let ids = null;
        if (typeof this.settings.id === 'string') {
            ids = [this.settings.id];
        }
        else if (Array.isArray(this.settings.id)) {
            ids = this.settings.id;
        }
        if (ids) {
            return ids.map(id => this.properties[id]);
        }
        const idProps = Object.keys(this.properties)
            .map(p => this.properties[p])
            .filter(prop => prop.id);
        return idProps;
    }
}
exports.ModelDefinition = ModelDefinition;
/**
 * Base class for models
 */
class Model {
    /**
     * Serialize into a plain JSON object
     */
    toJSON() {
        const json = {};
        const def = this.constructor.definition;
        for (const p in def.properties) {
            if (p in this) {
                json[p] = this[p];
            }
        }
        return json;
    }
    /**
     * Convert to a plain object as DTO
     */
    toObject(options) {
        let obj;
        if (options && options.ignoreUnknownProperties === false) {
            obj = {};
            for (const p in this) {
                obj[p] = this[p];
            }
        }
        else {
            obj = this.toJSON();
        }
        return obj;
    }
}
exports.Model = Model;
/**
 * Base class for value objects - An object that contains attributes but has no
 * conceptual identity. They should be treated as immutable.
 */
class ValueObject extends Model {
}
exports.ValueObject = ValueObject;
/**
 * Base class for entities which have unique ids
 */
class Entity extends Model {
    /**
     * Get the identity value. If the identity is a composite key, returns
     * an object.
     */
    getId() {
        const definition = this.constructor.definition;
        const idProps = definition.idProperties();
        if (idProps.length === 1) {
            return this[idProps[0].name];
        }
        const idObj = {};
        for (const idProp of idProps) {
            idObj[idProp.name] = this[idProp.name];
        }
        return idObj;
    }
    /**
     * Get the identity as an object, such as `{id: 1}` or
     * `{schoolId: 1, studentId: 2}`
     */
    getIdObject() {
        const definition = this.constructor.definition;
        const idProps = definition.idProperties();
        const idObj = {};
        for (const idProp of idProps) {
            idObj[idProp.name] = this[idProp.name];
        }
        return idObj;
    }
    /**
     * Build the where object for the given id
     */
    static buildWhereForId(id) {
        const where = {};
        const idProps = this.definition.idProperties();
        if (idProps.length === 1) {
            where[idProps[0].name] = id;
        }
        else {
            for (const idProp of idProps) {
                where[idProp.name] = id[idProp.name];
            }
        }
        return where;
    }
}
exports.Entity = Entity;
/**
 * Domain events
 */
class Event {
}
exports.Event = Event;
//# sourceMappingURL=model.js.map