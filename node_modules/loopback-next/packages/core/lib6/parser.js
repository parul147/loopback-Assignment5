"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/core
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require("./");
const promisify_1 = require("./promisify");
const jsonBody = require('body/json');
// tslint:enable:no-any
const parseJsonBody = promisify_1.promisify(jsonBody);
/**
 * Get the content-type header value from the request
 * @param req Http request
 */
function getContentType(req) {
    const val = req.headers['content-type'];
    if (typeof val === 'string') {
        return val;
    }
    else if (Array.isArray(val)) {
        // Assume only one value is present
        return val[0];
    }
    return undefined;
}
function parseOperationArgs(request, operationSpec, pathParams) {
    return __awaiter(this, void 0, void 0, function* () {
        const args = [];
        const body = yield loadRequestBodyIfNeeded(operationSpec, request);
        return buildOperationArguments(operationSpec, request, pathParams, body);
    });
}
exports.parseOperationArgs = parseOperationArgs;
function loadRequestBodyIfNeeded(operationSpec, request) {
    if (!hasArgumentsFromBody(operationSpec))
        return Promise.resolve();
    const contentType = getContentType(request);
    if (contentType && !/json/.test(contentType)) {
        const err = new _1.HttpErrors.UnsupportedMediaType(`Content-type ${contentType} is not supported.`);
        return Promise.reject(err);
    }
    return parseJsonBody(request).catch((err) => {
        err.statusCode = 400;
        return Promise.reject(err);
    });
}
function hasArgumentsFromBody(operationSpec) {
    if (!operationSpec.parameters || !operationSpec.parameters.length)
        return false;
    for (const paramSpec of operationSpec.parameters) {
        if ('$ref' in paramSpec)
            continue;
        const source = paramSpec.in;
        if (source === 'formData' || source === 'body')
            return true;
    }
    return false;
}
function buildOperationArguments(operationSpec, request, pathParams, body) {
    const args = [];
    for (const paramSpec of operationSpec.parameters || []) {
        if ('$ref' in paramSpec) {
            // TODO(bajtos) implement $ref parameters
            throw new Error('$ref parameters are not supported yet.');
        }
        const spec = paramSpec;
        switch (spec.in) {
            case 'query':
                args.push(request.query[spec.name]);
                break;
            case 'path':
                args.push(pathParams[spec.name]);
                break;
            case 'header':
                args.push(request.headers[spec.name.toLowerCase()]);
                break;
            case 'formData':
                args.push(body ? body[spec.name] : undefined);
                break;
            case 'body':
                args.push(body);
                break;
            default:
                throw new _1.HttpErrors.NotImplemented('Parameters with "in: ' + spec.in + '" are not supported yet.');
        }
    }
    return args;
}
//# sourceMappingURL=parser.js.map