"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/core
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const url = require("url");
const debug = require('debug')('loopback:core:routing-table');
// TODO(bajtos) Refactor this code to use Trie-based lookup,
// e.g. via wayfarer/trie or find-my-way
const pathToRegexp = require("path-to-regexp");
function parseRequestUrl(request) {
    // TODO(bajtos) The following parsing can be skipped when the router
    // is mounted on an express app
    const parsedRequest = request;
    const parsedUrl = url.parse(parsedRequest.url, true);
    parsedRequest.path = parsedUrl.pathname || '/';
    parsedRequest.query = parsedUrl.query;
    return parsedRequest;
}
exports.parseRequestUrl = parseRequestUrl;
class RoutingTable {
    constructor() {
        this._routes = [];
    }
    registerController(controller, spec) {
        assert(typeof spec === 'object' && !!spec, 'API specification must be a non-null object');
        if (!spec.paths || !Object.keys(spec.paths).length) {
            return;
        }
        debug('Registering Controller with API', spec);
        for (const path in spec.paths) {
            for (const verb in spec.paths[path]) {
                const opSpec = spec.paths[path][verb];
                // TODO(bajtos) handle the case where opSpec.parameters contains $ref
                debug('  %s %s -> %s(%s)', verb, path, opSpec['x-operation-name'], (opSpec.parameters || [])
                    .map(p => p.name)
                    .join(', '));
                this._routes.push(new RouteEntry(path, verb, opSpec, controller));
            }
        }
    }
    find(request) {
        for (const entry of this._routes) {
            const match = entry.match(request);
            if (match)
                return match;
        }
        return undefined;
    }
}
exports.RoutingTable = RoutingTable;
class RouteEntry {
    constructor(path, verb, _spec, _controller) {
        this._spec = _spec;
        this._controller = _controller;
        this._verb = verb.toLowerCase();
        // In Swagger, path parameters are wrapped in `{}`.
        // In Express.js, path parameters are prefixed with `:`
        path = path.replace(/{([^}]*)}(\/|$)/g, ':$1$2');
        this._pathRegexp = pathToRegexp(path, [], { strict: false, end: true });
    }
    match(request) {
        debug('trying endpoint', this);
        if (this._verb !== request.method.toLowerCase()) {
            debug(' -> verb mismatch');
            return undefined;
        }
        const match = this._pathRegexp.exec(request.path);
        if (!match) {
            debug(' -> path mismatch');
            return undefined;
        }
        const pathParams = this._buildPathParams(match);
        debug(' -> found with params: %j', pathParams);
        return this._createResolvedRoute(pathParams);
    }
    _createResolvedRoute(pathParams) {
        return {
            controller: this._controller,
            methodName: this._spec['x-operation-name'],
            spec: this._spec,
            pathParams: pathParams,
        };
    }
    _buildPathParams(pathMatch) {
        const pathParams = Object.create(null);
        for (const ix in this._pathRegexp.keys) {
            const key = this._pathRegexp.keys[ix];
            const matchIndex = +ix + 1;
            pathParams[key.name] = pathMatch[matchIndex];
        }
        return pathParams;
    }
}
//# sourceMappingURL=routing-table.js.map