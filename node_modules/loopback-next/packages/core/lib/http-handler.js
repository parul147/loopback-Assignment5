"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/core
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const HttpErrors = require("http-errors");
const routing_table_1 = require("./router/routing-table");
const debug = require('debug')('loopback:core:http-handler');
class HttpHandler {
    constructor(_rootContext) {
        this._rootContext = _rootContext;
        this._routes = new routing_table_1.RoutingTable();
        this.handleRequest = (req, res) => this._handleRequest(req, res);
    }
    registerController(name, spec) {
        this._routes.registerController(name, spec);
    }
    async _handleRequest(request, response) {
        const parsedRequest = routing_table_1.parseRequestUrl(request);
        const requestContext = this._createRequestContext(request, response);
        this._bindFindRoute(requestContext);
        this._bindInvokeMethod(requestContext);
        const sequence = await requestContext.get('sequence');
        return sequence.run(parsedRequest, response);
    }
    _createRequestContext(req, res) {
        const requestContext = new context_1.Context(this._rootContext);
        requestContext.bind('http.request').to(req);
        requestContext.bind('http.response').to(res);
        return requestContext;
    }
    _bindFindRoute(context) {
        context.bind('findRoute').toDynamicValue(() => {
            return (request) => {
                const req = context.getSync('http.request');
                const found = this._routes.find(req);
                if (!found)
                    throw new HttpErrors.NotFound(`Endpoint "${req.method} ${req.path}" not found.`);
                // bind routing information to context
                const ctor = context.getBinding(found.controller).valueConstructor;
                if (!ctor)
                    throw new Error(`The controller ${found.controller} was not bound via .toClass()`);
                context.bind('controller.current.ctor').to(ctor);
                context.bind('controller.current.operation').to(found.methodName);
                return found;
            };
        });
    }
    _bindInvokeMethod(context) {
        context.bind('invokeMethod').toDynamicValue(() => {
            return async (controllerName, method, args) => {
                const controller = await context.get(controllerName);
                const result = await controller[method](...args);
                return result;
            };
        });
    }
}
exports.HttpHandler = HttpHandler;
//# sourceMappingURL=http-handler.js.map