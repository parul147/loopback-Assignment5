"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/core
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("@loopback/context");
const metadata_1 = require("./router/metadata");
const http_handler_1 = require("./http-handler");
const sequence_1 = require("./sequence");
const debug = require('debug')('loopback:core:application');
class Application extends context_1.Context {
    constructor(options) {
        super();
        this.options = options;
        if (options && options.components) {
            for (const component of options.components) {
                // TODO(superkhau): Need to figure a way around this hack,
                //  `componentClassName.constructor.name` + `componentClassName.name`
                //  doesn't work
                const componentClassName = component.toString().split(' ')[1];
                this.bind(`component.${componentClassName}`).toClass(component);
            }
        }
        this._bindSequence();
        this.handleHttp = (req, res) => this._handleHttpRequest(req, res);
        this.bind('logError').to(this._logError.bind(this));
    }
    _bindSequence() {
        // TODO(bajtos, ritch, superkhau) figure out how to integrate this single
        // sequence with custom sequences contributed by components
        const sequence = this.options && this.options.sequence
            ? this.options.sequence
            : sequence_1.Sequence;
        this.bind('sequence').toClass(sequence);
    }
    _handleHttpRequest(request, response) {
        this._setupHandlerIfNeeded();
        return this._httpHandler.handleRequest(request, response);
    }
    _setupHandlerIfNeeded() {
        // TODO(bajtos) support hot-reloading of controllers
        // after the app started. The idea is to rebuild the HttpHandler
        // instance whenever a controller was added/deleted.
        if (this._httpHandler)
            return;
        this._httpHandler = new http_handler_1.HttpHandler(this);
        for (const b of this.find('controllers.*')) {
            const ctor = b.valueConstructor;
            if (!ctor) {
                throw new Error(`The controller ${b.key} was not bound via .toClass()`);
            }
            const apiSpec = metadata_1.getApiSpec(ctor);
            this._httpHandler.registerController(b.key, apiSpec);
        }
    }
    /**
     * Register a controller class with this application.
     *
     * @param controllerCtor {Function} The controller class
     * (constructor function).
     * @return {Binding} The newly created binding, you can use the reference to
     * further modify the binding, e.g. lock the value to prevent further
     * modifications.
     *
     * ```ts
     * @spec(apiSpec)
     * class MyController {
     * }
     * app.controller(MyController).lock();
     * ```
     */
    controller(controllerCtor) {
        return this.bind('controllers.' + controllerCtor.name).toClass(controllerCtor);
    }
    _logError(err, statusCode, req) {
        console.error('Unhandled error in %s %s: %s %s', req.method, req.url, statusCode, err.stack || err);
    }
}
exports.Application = Application;
//# sourceMappingURL=application.js.map